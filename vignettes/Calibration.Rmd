---
title: "Calibration"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Calibration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = TRUE,
  autodep = TRUE
)
```

```{r setup, eval=FALSE}
library(RSVsim)
```

In this vignette, we give an overview of how to use an Approximate Bayesian Computation (ABC) rejection algorithm to calibrate the mathematical model of RSV transmission to simulated data. The code to run these samplers was adapted from code provided in Minter, Amanda, and Renata Retkute. "Approximate Bayesian Computation for infectious disease modelling." Epidemics 29 (2019): 100368 <https://doi.org/10.1016/j.epidem.2019.100368>. 

First, we run the model to generate some data to fit to.

```{r simulated_data, dependson="setup", eval=FALSE}

# specify age categories to run the model with
age_limits <- c(seq(0, 2, 0.2), seq(10, 60, 5))

# get contact matrix
contact_population_list <- RSVsim_contact_matrix(country = "United Kingdom", age_limits = age_limits)

# get the default model parameters with a b0 value of 0.08, b1 value of 0, phi value of 0 and change the initial conditions 
overrides <- list("b0" = 0.11, "b1" = 0.3, "phi" = 10)

parameters <- fixed_parameter_list <- RSVsim_parameters(overrides = overrides, 
                                                        contact_population_list = contact_population_list)

out <- RSVsim_run_model(parameters = parameters,
                        times = seq(0, 365, 0.25), # maximum time to run the model for
                        cohort_step_size = 0.2 * 365, # time at which to age people\
                        warm_up = NULL)

fitted_parameter_names <- c("b0", "b1", "phi")

nAges <- parameters[["nAges"]]

```

Next, we define a function to calculate some summary statistics from the model output. Specifically, we calculate the age-specific peak time of incidence infections, the amplitude of incidence (difference between maximum and minimum incidence) and the total yearly incidence. RSVsim has built in functions to calculate these metrics from the model output. We define a function summary_fun to combine these metrics. We will use these as the target for the ABC-rejection algorithm. We must also specify a function that randomly samples from the prior distributions of all fitted parameters and returns a vector of the parameters. We use latin hypercube sampling to efficiently sample the prior space. In this example we fit the b0 and b1 parameters. A vector of the parameter names that are being fitted in the same order as the prior samples must also be provided to set up the parameters to run the model.

```{r summary_functions, dependson = "simulated_data", eval = FALSE}

#########################
##### ABC functions #####
#########################

# calculate the summary statistics
summary_fun <- function(out){
  return(c(RSVsim_total_incidence(out), RSVsim_amplitude(out), RSVsim_peak(out)))
}

target <- summary_fun(out)

# a function that samples from the priors is required
# we use latin hypercube sampling to efficiently sample from the prior distributions
prior_fun <- function(n_prior_attempts){
  
  x <- lhs::randomLHS(n_prior_attempts, 4)
  
  # adjusting the prior distributions
  x[,1] <- qunif(x[,1], min = 0.05, max = 0.25)
  x[,2] <- qunif(x[,2], min = 0, max = 1) # not necessary but added for completeness
  x[,3] <- qunif(x[,3], min = -365.25/2, max = 365.25/2)
  
  x_out <- data.frame("b0" = x[,1],
                      "b1" = x[,2],
                      "phi" = x[,3])
  
  return(x_out)
}

# a function that calculates the distance between the summary statistics is required
dist_fun <- function(target, target_star, n = nAges){
  return(
    c(
      RSVsim_abs_dist_fun(target[1:n], target_star[1:n]),
      RSVsim_abs_dist_fun(target[(n+1):(n*2)], target_star[(n+1):(n*2)]),
      RSVsim_shortest_periodic_dist_fun(target[(2*n+1):(n*3)], target_star[(2*n+1):(n*3)], period = 365.25)
    )
  )

}

```

To implement the ABC-rejection algorithm we must specify the tolerance. We specify a specific tolerance for each metric that means approximately 1% of all simulations are accepted.

```{r calc_tol, dependson = "summary_functions", eval = FALSE}
#################################
##### setting the tolerance #####
#################################
# calculating a tolerance that means at least 1 particle combination is accepted every 100 simulations
# getting 100 samples from the priors
set.seed(123)
n_check <- 1000
prior_params <- prior_fun(n_check)

# simulating the summary statistics for each particle
prior_distances <- sapply(1:n_check, function(i){
  parameters_in <- RSVsim_update_parameters(fixed_parameter_list, fitted_parameter_names, prior_params[i, ])
  
  out <- RSVsim_run_model(parameters = parameters_in,
                   times = seq(0, 365*1, 0.25), # maximum time to run the model for
                   cohort_step_size = 0.2*365, # time at which to age people
                   warm_up = NULL)
  
  return(dist_fun(target, summary_fun(out)))
})

# calculating the number of particles for which all summary statistics are within the tolerance given different percentiles of the summary statistics 
nsuccess <- rep(NA, n_check)
q <- seq(0.01, 1, 0.01)
for(i in 1:100){
  epsilon_check <- round(apply(prior_distances, 1, quantile, probs = c(q[i])), digits = 2)
  nsuccess[i] <- sum(sapply(1:100, function(j){all(prior_distances[,j] <= epsilon_check)}))
}

# selecting a tolerance where at least 1 particle is accepted for the 100 simulations
epsilon <- round(apply(prior_distances, 1, quantile, probs = c(q[min(which(nsuccess >= 1))])), digits = 2)

```

To run the model we specify the number of particles to fit, and the seeds for each particle. The number of cores can also be specified - if greater than one then parallel processing is implemented using a parallel socket cluster with the parallel R package.

```{r run_ABC, dependson="calc_tol", eval=FALSE}
###############################################
##### running the ABC-rejection algorithm #####
###############################################

nparticles = 500

used_seeds_all <- seq(1, nparticles)

ncores <- 8

fit <- RSVsim_ABC_rejection(target = target,
                            epsilon = epsilon,
                            summary_fun = summary_fun,
                            dist_fun = dist_fun,
                            prior_fun = prior_fun,
                            n_prior_attempts = 10000,
                            nparticles = nparticles,
                            used_seeds_all = used_seeds_all,
                            ncores = ncores,
                            fitted_parameter_names = fitted_parameter_names,
                            fixed_parameter_list = fixed_parameter_list,
                            times = seq(0, 365, 0.25), # maximum time to run the model for
                            cohort_step_size = 0.2*365, # time at which to age people\
                            warm_up = NULL)

fit_b0 <- unlist(fit[,"b0"])
fit_b1 <- unlist(fit[,"b1"])
fit_phi <- unlist(fit[,"phi"])

hist(fit_b0)
hist(fit_b1)
hist(fit_phi)

```

We also provide a function to run a Sequential Monte Carlo ABC algorithm (ABC-SMC). The ABC-SMC algorithm also requires a function to return the prior density and a sequential reduction in the tolerances.

```{r run_ABC_SMC, dependson="calc_tol", eval=FALSE}

prior_dens_fun <- function(x){
  
  # adjusting the prior distributions
  return(c(dunif(x[[1]], min = 0.05, max = 0.25),
           dunif(x[[2]], min = 0, max = 1),
           dunif(x[[3]], min = -365.25/2, max = 365.25/2)
           )
         )
}

nsuccess <- rep(NA, n_check)
q <- seq(1/n_check, 1, 1/n_check)
for(i in 1:n_check){
  epsilon_check <- round(apply(prior_distances, 1, quantile, probs = c(q[i])), digits = 5)
  nsuccess[i] <- sum(sapply(1:n_check, function(j){all(prior_distances[,j] <= epsilon_check)}))
}

acceptance_rate <- sort(c(1, 10, 50, 75), decreasing = TRUE)

q_percentile <- vector(mode = "list", length = length(acceptance_rate))

q_percentile <- lapply(acceptance_rate, function(ar){q[min(which(nsuccess/n_check * 100 > ar))]}) # 1

q_percentile_ar1 <- q_percentile[[which(acceptance_rate == 1)]]

# selecting a tolerance where at least 1 particle is accepted for the 100 simulations
epsilon_matrix <- as.matrix(do.call(rbind, lapply(q_percentile, function(q){round(apply(prior_distances, 1, quantile, probs = q), digits = 3)})))

G <- nrow(epsilon_matrix)

used_seed_matrix <- matrix(seq(1, nparticles * G), nrow = G)

fit_smc <- RSVsim_ABC_SMC(target = target,
                          epsilon_matrix = epsilon_matrix,
                          summary_fun = summary_fun,
                          dist_fun = dist_fun,
                          prior_fun = prior_fun,
                          n_param_attempts_per_accept = 100,
                          used_seed_matrix = used_seed_matrix,
                          prior_dens_fun = prior_dens_fun,
                          particle_low = c(0.05, 0, -365.25/2),
                          particle_up = c(0.25, 1, 365.25/2),
                          nparticles = nparticles,
                          ncores = ncores,
                          fitted_parameter_names = fitted_parameter_names,
                          fixed_parameter_list = fixed_parameter_list,
                          times = seq(0, 365, 0.25), # maximum time to run the model for
                          cohort_step_size = 0.2*365, # time at which to age people
                          warm_up = NULL)

```
